// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract FanDraftGame {
    address public owner;
    uint256 public draftCounter;
    uint256 public entryFee; // In wei
    uint256 public platformRevenue;

    struct DraftEntry {
        address player;
        uint256[] playerIds;
        uint256 score;
        bool claimedReward;
    }

    struct Draft {
        uint256 id;
        bool isActive;
        address[] participants;
        mapping(address => DraftEntry) entries;
        address[] winners; // Top 3
        uint256 totalPool;
        uint256 deadline;
    }

    string[] public draftNames;

    mapping(uint256 => Draft) public drafts;
    mapping(address => uint256) public totalWins;


    modifier onlyOwner() {
        require(msg.sender == owner, "Only admin can perform this action");
        _;
    }

    constructor(uint256 _entryFee) {
        owner = msg.sender;
        entryFee = _entryFee;
    }

    function createDraft(string memory draftName, uint256 durationSeconds) external onlyOwner {
        draftCounter++;
        Draft storage d = drafts[draftCounter];
        d.id = draftCounter;
        d.isActive = true;
        d.deadline = block.timestamp + durationSeconds;

        draftNames.push(draftName);
    }

    function getDraft(
        uint256 draftId
    ) external view returns (
        uint256 id,
        // string memory name,
        bool isActive,
        uint256 totalPool,
        uint256 deadline
    ) {
        uint256 _id = drafts[draftId].id;
        // string memory _name = drafts[draftId].name;
        bool _isActive = drafts[draftId].isActive;
        uint256 _totalPool = drafts[draftId].totalPool;
        uint256 _deadline = drafts[draftId].deadline;

        return (_id, _isActive, _totalPool, _deadline);
    }

    function getDraftName(uint256 draftId) public view returns (string memory) {
        require(draftId > 0 && draftId <= draftNames.length, "Invalid draft ID");
        return draftNames[draftId - 1]; // âœ… Adjust for 0-based index
    }

    function getAllDraftNames() public view returns (string[] memory) {
        return draftNames;
    }


    function joinDraft(uint256 draftId, uint256[] memory selectedPlayers) external payable {
        Draft storage d = drafts[draftId];
        require(d.isActive, "Draft not active");
        require(block.timestamp <= d.deadline, "Draft deadline passed");
        require(msg.value == entryFee, "Incorrect entry fee");
        require(selectedPlayers.length == 11, "Must select 11 players");
        require(d.entries[msg.sender].player == address(0), "Already joined");

        d.entries[msg.sender] = DraftEntry({
            player: msg.sender,
            playerIds: selectedPlayers,
            score: 0,
            claimedReward: false
        });

        d.participants.push(msg.sender);
        d.totalPool += msg.value;
    }

    function resolveDraft(uint256 draftId, address[] memory winnerAddresses, uint256[] memory scores) external onlyOwner {
        Draft storage d = drafts[draftId];
        require(d.isActive, "Draft already resolved");
        require(block.timestamp > d.deadline, "Draft still ongoing");
        require(winnerAddresses.length == 3 && scores.length == 3, "Top 3 required");

        d.isActive = false;
        d.winners = winnerAddresses;

        uint256 pool = d.totalPool;
        uint256 firstPrize = (pool * 60) / 100;
        uint256 secondPrize = (pool * 25) / 100;
        uint256 thirdPrize = (pool * 15) / 100;

        platformRevenue += pool - (firstPrize + secondPrize + thirdPrize);

        // Distribute rewards
        (bool sent1, ) = winnerAddresses[0].call{value: firstPrize}("");
        require(sent1, "1st prize transfer failed");

        (bool sent2, ) = winnerAddresses[1].call{value: secondPrize}("");
        require(sent2, "2nd prize transfer failed");

        (bool sent3, ) = winnerAddresses[2].call{value: thirdPrize}("");
        require(sent3, "3rd prize transfer failed");

        // Store scores and update wins
        for (uint256 i = 0; i < 3; i++) {
            d.entries[winnerAddresses[i]].score = scores[i];
            totalWins[winnerAddresses[i]]++;
        }

        emit DraftResolved(draftId, winnerAddresses, scores);
    }

    function getParticipants(uint256 draftId) public view returns (address[] memory) {
        return drafts[draftId].participants;
    }

    function getPlayerSelection(uint256 draftId, address user) public view returns (uint256[] memory) {
        return drafts[draftId].entries[user].playerIds;
    }

    function getDraftWinners(uint256 draftId) public view returns (address[] memory) {
        return drafts[draftId].winners;
    }

    function withdrawRevenue() external onlyOwner {
        require(platformRevenue > 0, "No revenue to withdraw");

        uint256 amount = platformRevenue;
        platformRevenue = 0;

        (bool sent, ) = owner.call{value: amount}("");
        require(sent, "Withdraw failed");
    }

    function changeEntryFee(uint256 newFee) external onlyOwner {
        entryFee = newFee;
    }

    event DraftResolved(uint256 indexed draftId, address[] winners, uint256[] scores);

    receive() external payable {}
    fallback() external payable {}
}
